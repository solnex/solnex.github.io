<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Uniswap v3 详解（二）：创建交易对/提供流动性 | Solnex</title><meta name="author" content="Solnex"><meta name="copyright" content="Solnex"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="前文已经说过 Uniswap v3 的代码架构。一般来说，用户的操作都是从 uniswap-v3-periphery 中的合约开始。 创建交易对创建交易对的调用流程如下： 用户首先调用 NonfungiblePositionManager 合约的 createAndInitializePoolIfNecessary 方法创建交易对，传入的参数为交易对的 token0, token1, fee 和初">
<meta property="og:type" content="article">
<meta property="og:title" content="Uniswap v3 详解（二）：创建交易对&#x2F;提供流动性">
<meta property="og:url" content="https://solnex.github.io/2024/02/16/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/index.html">
<meta property="og:site_name" content="Solnex">
<meta property="og:description" content="前文已经说过 Uniswap v3 的代码架构。一般来说，用户的操作都是从 uniswap-v3-periphery 中的合约开始。 创建交易对创建交易对的调用流程如下： 用户首先调用 NonfungiblePositionManager 合约的 createAndInitializePoolIfNecessary 方法创建交易对，传入的参数为交易对的 token0, token1, fee 和初">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://solnex.github.io/img/icon.jpg">
<meta property="article:published_time" content="2024-02-15T16:00:00.000Z">
<meta property="article:modified_time" content="2025-11-20T07:35:54.773Z">
<meta property="article:author" content="Solnex">
<meta property="article:tag" content="amm">
<meta property="article:tag" content="uniswap-v3">
<meta property="article:tag" content="集中流动性">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://solnex.github.io/img/icon.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Uniswap v3 详解（二）：创建交易对/提供流动性",
  "url": "https://solnex.github.io/2024/02/16/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/",
  "image": "https://solnex.github.io/img/icon.jpg",
  "datePublished": "2024-02-15T16:00:00.000Z",
  "dateModified": "2025-11-20T07:35:54.773Z",
  "author": [
    {
      "@type": "Person",
      "name": "Solnex",
      "url": "https://solnex.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://solnex.github.io/2024/02/16/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Uniswap v3 详解（二）：创建交易对/提供流动性',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><style>body{background-image:url(/img/bg.jpg);background-attachment:fixed;background-size:cover;background-position:center;}#page-header{transition:opacity 0.3s ease;}</style><meta name="generator" content="Hexo 8.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/banner.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Solnex</span></a><a class="nav-page-title" href="/"><span class="site-name">Uniswap v3 详解（二）：创建交易对/提供流动性</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Uniswap v3 详解（二）：创建交易对/提供流动性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-02-15T16:00:00.000Z" title="Created 2024-02-16 00:00:00">2024-02-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-20T07:35:54.773Z" title="Updated 2025-11-20 15:35:54">2025-11-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DeFi/">DeFi</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DeFi/Uniswap/">Uniswap</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>前文已经说过 Uniswap v3 的<a target="_blank" rel="noopener" href="https://paco0x.org/uniswap-v3-1/#%e4%bb%a3%e7%a0%81%e6%9e%b6%e6%9e%84">代码架构</a>。一般来说，用户的操作都是从 <a target="_blank" rel="noopener" href="https://github.com/Uniswap/uniswap-v3-periphery">uniswap-v3-periphery</a> 中的合约开始。</p>
<h2 id="创建交易对"><a href="#创建交易对" class="headerlink" title="创建交易对"></a>创建交易对</h2><p>创建交易对的调用流程如下：</p>
<p><img src="https://paco0x.org/img/in-post/uniswap-v3/create-pool.png" alt="Image 1: create-pool"><br>用户首先调用 <code>NonfungiblePositionManager</code> 合约的 <code>createAndInitializePoolIfNecessary</code> 方法创建交易对，传入的参数为交易对的 token0, token1, fee 和初始价格 P\sqrt P.</p>
<p><code>NonfungiblePositionManager</code> 合约内部通过调用 <code>UniswapV3Factory</code> 的 <code>createPool</code> 方法完成交易对的创建，然后对交易对进行初始化，初始化的作用就是给交易对设置一个初始的价格。</p>
<p><code>createAndInitializePoolIfNecessary</code> 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function createAndInitializePoolIfNecessary(</span><br><span class="line">    address tokenA,</span><br><span class="line">    address tokenB,</span><br><span class="line">    uint24 fee,</span><br><span class="line">    uint160 sqrtPriceX96</span><br><span class="line">) external payable returns (address pool) &#123;</span><br><span class="line">    pool = IUniswapV3Factory(factory).getPool(tokenA, tokenB, fee);</span><br><span class="line"></span><br><span class="line">    if (pool == address(0)) &#123;</span><br><span class="line">        pool = IUniswapV3Factory(factory).createPool(tokenA, tokenB, fee);</span><br><span class="line">        IUniswapV3Pool(pool).initialize(sqrtPriceX96);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        (uint160 sqrtPriceX96Existing, , , , , , ) = IUniswapV3Pool(pool).slot0();</span><br><span class="line">        if (sqrtPriceX96Existing == 0) &#123;</span><br><span class="line">            IUniswapV3Pool(pool).initialize(sqrtPriceX96);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用 <code>UniswapV3Factory.getPool</code> 方法查看交易对是否已经创建，<code>getPool</code> 函数是 solidity 自动为 <code>UniswapV3Factory</code> 合约中的状态变量 <code>getPool</code> 生成的外部函数，<code>getPool</code> 的数据类型为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall &#123;</span><br><span class="line">    ...</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; address))) public override getPool;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 3个 map 说明了 v3 版本使用 <code>(tokenA, tokenB, fee)</code> 来作为一个交易对的键，即相同代币，不同费率之间的流动池不一样。另外对于给定的 <code>tokenA</code> 和 <code>tokenB</code>，会先将其地址排序，将地址值更小的放在前，这样方便后续交易池的查询和计算。</p>
<p>再来看 <code>UniswapV3Factory</code> 创建交易对的过程，实际上它是调用 <code>deploy</code> 函数完成交易对的创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function deploy(</span><br><span class="line">    address factory,</span><br><span class="line">    address token0,</span><br><span class="line">    address token1,</span><br><span class="line">    uint24 fee,</span><br><span class="line">    int24 tickSpacing</span><br><span class="line">) internal returns (address pool) &#123;</span><br><span class="line">    parameters = Parameters(&#123;factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing&#125;);</span><br><span class="line">    pool = address(new UniswapV3Pool&#123;salt: keccak256(abi.encode(token0, token1, fee))&#125;());</span><br><span class="line">    delete parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>fee</code> 和 <code>tickSpacing</code> 是和费率及价格最小间隔相关的设置，这里只关注创建过程，费率和 tick 的实现后面再来做介绍。</p>
<h2 id="CREATE2"><a href="#CREATE2" class="headerlink" title="CREATE2"></a>CREATE2</h2><p>创建交易对，就是创建一个新的合约，作为流动池来提供交易功能。创建合约的步骤是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool = address(new UniswapV3Pool&#123;salt: keccak256(abi.encode(token0, token1, fee))&#125;());</span><br></pre></td></tr></table></figure>

<p>这里先通过 <code>keccak256(abi.encode(token0, token1, fee)</code> 将 <code>token0</code>, <code>token1</code>, <code>fee</code> 作为输入，得到一个哈希值，并将其作为 <code>salt</code> 来创建合约。因为指定了 <code>salt</code>, solidity 会使用 EVM 的 <code>CREATE2</code> 指令来创建合约。使用 <code>CREATE2</code> 指令的好处是，只要合约的 <code>bytecode</code> 及 <code>salt</code> 不变，那么创建出来的地址也将不变。</p>
<p>关于使用 salt 创建合约的解释：<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/latest/control-structures.html#salted-contract-creations-create2">Salted contract creations &#x2F; create2</a></p>
<blockquote>
<p><code>CREATE2</code> 指令的具体解释可以参考：<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>。solidity 在 0.6.2 版本后在语法层面支持了 <code>CREATE2</code>. 如果使用更低的版本，可以参考 <a target="_blank" rel="noopener" href="https://github.com/Uniswap/uniswap-v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/UniswapV2Factory.sol#L28-L32">Uniswap v2</a> 的代码实现同样的功能。</p>
</blockquote>
<p>使用 <code>CREATE2</code> 的好处是：</p>
<ul>
<li>可以在链下计算出已经创建的交易池的地址</li>
<li>其他合约不必通过 <code>UniswapV3Factory</code> 中的接口来查询交易池的地址，可以节省 gas</li>
<li>合约地址不会因为 reorg 而改变</li>
</ul>
<p>不需要通过 <code>UniswapV3Factory</code> 的接口来计算交易池合约地址的方法，可以看<a target="_blank" rel="noopener" href="https://github.com/Uniswap/uniswap-v3-periphery/blob/3514c56ccf84a2d32b623004e7c119494ac729cc/contracts/libraries/PoolAddress.sol#L15-L38">这段代码</a>。</p>
<p>新交易对合约的构造函数中会反向查询 <code>UniswapV3Factory</code> 中的 parameters 值来进行初始变量的赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    int24 _tickSpacing;</span><br><span class="line">    (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();</span><br><span class="line">    tickSpacing = _tickSpacing;</span><br><span class="line"></span><br><span class="line">    maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不直接使用参数传递来对新合约的状态变量赋值呢。这是因为 <code>CREATE2</code> 会将合约的 <code>initcode</code> 和 <code>salt</code> 一起用来计算创建出的合约地址。而 <code>initcode</code> 是包含 <code>contructor</code> code 和其参数的，如果合约的 <code>constructor</code> 函数包含了参数，那么其 <code>initcode</code> 将因为其传入参数不同而不同。在 off-chain 计算合约地址时，也需要通过这些参数来查询对应的 <code>initcode</code>。为了让合约地址的计算更简单，这里的 <code>constructor</code> 不包含参数（这样合约的 <code>initcode</code> 将时唯一的），而是使用动态 call 的方式来获取其创建参数。</p>
<p>最后，对创建的交易对合约进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function initialize(uint160 sqrtPriceX96) external override &#123;</span><br><span class="line">    require(slot0.sqrtPriceX96 == 0, &#x27;AI&#x27;);</span><br><span class="line"></span><br><span class="line">    int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span><br><span class="line"></span><br><span class="line">    (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());</span><br><span class="line"></span><br><span class="line">    slot0 = Slot0(&#123;</span><br><span class="line">        sqrtPriceX96: sqrtPriceX96,</span><br><span class="line">        tick: tick,</span><br><span class="line">        observationIndex: 0,</span><br><span class="line">        observationCardinality: cardinality,</span><br><span class="line">        observationCardinalityNext: cardinalityNext,</span><br><span class="line">        feeProtocol: 0,</span><br><span class="line">        unlocked: true</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    emit Initialize(sqrtPriceX96, tick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化主要是设置了交易池的初始价格（注意，此时池子中还没有流动性），以及费率，tick 等相关变量的初始化。完成之后一个交易池就创建好了。</p>
<h2 id="提供流动性"><a href="#提供流动性" class="headerlink" title="提供流动性"></a>提供流动性</h2><p>在合约内，v3 会保存所有用户的流动性，代码内称作 <code>Position</code>，提供流动性的调用流程如下：</p>
<p><img src="https://paco0x.org//img/in-post/uniswap-v3/add-liquidity.png" alt="Image 2: add-liquidity"><br>用户还是首先和 <code>NonfungiblePositionManager</code> 合约交互。v3 这次将 LP token 改成了 ERC721 token，并且将 token 功能放到 <code>NonfungiblePositionManager</code> 合约中。这个合约替代用户完成提供流动性操作，然后根据将流动性的数据元记录下来，并给用户铸造一个 NFT Token.</p>
<p>省略部分非关键步骤，我们先来看添加流动性的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct AddLiquidityParams &#123;</span><br><span class="line">    address token0;     // token0 的地址</span><br><span class="line">    address token1;     // token1 的地址</span><br><span class="line">    uint24 fee;         // 交易费率</span><br><span class="line">    address recipient;  // 流动性的所属人地址</span><br><span class="line">    int24 tickLower;    // 流动性的价格下限（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    int24 tickUpper;    // 流动性的价格上线（以 token0 计价），这里传入的是 tick index</span><br><span class="line">    uint128 amount;     // 流动性 L 的值</span><br><span class="line">    uint256 amount0Max; // 提供的 token0 上限数</span><br><span class="line">    uint256 amount1Max; // 提供的 token1 上限数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addLiquidity(AddLiquidityParams memory params)</span><br><span class="line">    internal</span><br><span class="line">    returns (</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1,</span><br><span class="line">        IUniswapV3Pool pool</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    PoolAddress.PoolKey memory poolKey =</span><br><span class="line">        PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;);</span><br><span class="line"></span><br><span class="line">    // 这里不需要访问 factory 合约，可以通过 token0, token1, fee 三个参数计算出 pool 的合约地址</span><br><span class="line">    pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));</span><br><span class="line"></span><br><span class="line">    (amount0, amount1) = pool.mint(</span><br><span class="line">        params.recipient,</span><br><span class="line">        params.tickLower,</span><br><span class="line">        params.tickUpper,</span><br><span class="line">        params.amount,</span><br><span class="line">        // 这里是 pool 合约回调所使用的参数</span><br><span class="line">        abi.encode(MintCallbackData(&#123;poolKey: poolKey, payer: msg.sender&#125;))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    require(amount0 &lt;= params.amount0Max);</span><br><span class="line">    require(amount1 &lt;= params.amount1Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几点值得注意：</p>
<ul>
<li><p>传入的 lower&#x2F;upper 价格是以 tick index 来表示的，因此需要在链下先计算好价格所对应的 tick index</p>
</li>
<li><p>传入的是流动性 L 的大小，这个也需要在链下先计算好，计算过程见<a target="_blank" rel="noopener" href="https://paco0x.org/uniswap-v3-2/#%e4%bb%8e-token-%e6%95%b0%e8%ae%a1%e7%ae%97%e6%b5%81%e5%8a%a8%e6%80%a7-l">下面</a></p>
</li>
<li><p>我们不需要访问 factory 就可以计算出 pool 的地址，实现原理见 <a target="_blank" rel="noopener" href="https://paco0x.org/uniswap-v3-2/#create2">CREATE2</a></p>
</li>
<li><p>这里有一个回调函数的参数。v3 使用回调函数来完成进行流动性 token 的支付操作，原因见<a target="_blank" rel="noopener" href="https://paco0x.org/uniswap-v3-2/#%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0">下面</a></p>
</li>
</ul>
<h2 id="从-token-数计算流动性-L"><a href="#从-token-数计算流动性-L" class="headerlink" title="从 token 数计算流动性 L"></a>从 token 数计算流动性 L</h2><p>如前所述，因为合约的参数接受的是流动性 LL 的值，我们需要在链下通过用户愿意提供流动性包含的 token 数，计算出 L，<del>这部分计算需要在前端界面预先算好</del>, （2020.06.06 更新，在 uniswap 最新的代码中，简化了接口的参数，不在需要在链下预计算 L，这部分计算已经在合约中实现了，但是原理是不变的，为了保持本文的完整性，文本不再进行修改，关于 uniswap 合约和本文中代码的差异，可以在看完本文后看这个 <a target="_blank" rel="noopener" href="https://github.com/Uniswap/uniswap-v3-periphery/commit/b6b885569786a319d853acc610ed03884fda9bee">commit</a>）。</p>
<p>假设用户提供流动性的价格范围是：$[P_a, \ P_b]\ (P_a &lt; P_b)$，代币池中的当前价格为 $P_c$，可以分成三种情况来计算流动性 L 的值：</p>
<ul>
<li>当前池中的价格  $P_{c} &lt; P_{a}$ ，如下图：</li>
</ul>
<p><img src="https://paco0x.org//img/in-post/uniswap-v3/c-below-a.webp" alt="Image 3: c-below-a"><br>此时添加的流动性全部为 x token，计算 L：</p>
<p>$<br>L &#x3D; \frac {\Delta x}{\frac 1{\sqrt {P_{a}}} - \frac 1{\sqrt {P_{b}}}}<br>$</p>
<ul>
<li>当前池中的价格 P c&gt;P b P_{c} &gt; P_{b}</li>
</ul>
<p><img src="https://paco0x.org//img/in-post/uniswap-v3/c-above-b.webp" alt="Image 4: c-above-b"><br>此时添加的流动性全部为 y token，计算 L：</p>
<p>$<br>L &#x3D; \frac {\Delta y}{\sqrt {P_{b}} - \sqrt {P_{a}}}<br>$</p>
<ul>
<li>当前池子中的价格 P c∈[P a,P b]P_{c} \in [P_{a}, P_{b}]，如下图：</li>
</ul>
<p><img src="https://paco0x.org//img/in-post/uniswap-v3/c-in-a-b.webp" alt="Image 5: c-in-a-b"><br>此时添加的流动性包含两个币种，可以通过任意一个 token 数量计算出 L:</p>
<p>$<br>L &#x3D; \frac {\Delta x}{\frac 1{\sqrt {P_{c}}} - \frac 1{\sqrt {P_{b}}}} &#x3D; \frac {\Delta y}{\sqrt {P_{c}} - \sqrt {P_{a}}}<br>$</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>使用回调函数原因是，将 <code>Position</code> 的 owner 和实际流动性 token 支付者解耦。这样可以让中间合约来管理用户的流动性，并将流动性 token 化。关于 token 化，Uniswap v3 默认实现了 ERC721 token（因为即使是同一个池子，流动性之间差异也也很大）。</p>
<p>例如，当用户通过 <code>NonfungiblePositionManager</code> 来提供流动性时，对于 <code>UniswapV3Pool</code> 合约来说，这个 <code>Position</code> 的 owner 是 <code>NonfungiblePositionManager</code>，而 <code>NonfungiblePositionManager</code> 再通过 NFT Token 将 <code>Position</code> 与用户关联起来。这样用户就可以将 LP token 进行转账或者抵押类操作。</p>
<p>在 <code>NonfungiblePositionManager</code> 中回调函数的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct MintCallbackData &#123;</span><br><span class="line">    PoolAddress.PoolKey poolKey;</span><br><span class="line">    address payer;         // 支付 token 的地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @inheritdoc IUniswapV3MintCallback</span><br><span class="line">function uniswapV3MintCallback(</span><br><span class="line">    uint256 amount0Owed,</span><br><span class="line">    uint256 amount1Owed,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override &#123;</span><br><span class="line">    MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));</span><br><span class="line">    CallbackValidation.verifyCallback(factory, decoded.poolKey);</span><br><span class="line"></span><br><span class="line">    // 根据传入的参数，使用 transferFrom 代用户向 Pool 中支付 token</span><br><span class="line">    if (amount0Owed &gt; 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);</span><br><span class="line">    if (amount1Owed &gt; 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="postion-更新"><a href="#postion-更新" class="headerlink" title="postion 更新"></a>postion 更新</h2><p>接着我们看 <code>UniswapV3Pool</code> 是如何添加流动性的。流动性的添加主要在 <code>UniswapV3Pool._modifyPosition</code> 中，这个函会先调用 <code>_updatePosition</code> 来创建或修改一个用户的 <code>Position</code>，省略其中的非关键步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">function _updatePosition(</span><br><span class="line">    address owner,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    int128 liquidityDelta,</span><br><span class="line">    int24 tick</span><br><span class="line">) private returns (Position.Info storage position) &#123;</span><br><span class="line">    // 获取用户的 Postion</span><br><span class="line">    position = positions.get(owner, tickLower, tickUpper);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 根据传入的参数修改 Position 对应的 lower/upper tick 中</span><br><span class="line">    // 的数据，这里可以是增加流动性，也可以是移出流动性</span><br><span class="line">    bool flippedLower;</span><br><span class="line">    bool flippedUpper;</span><br><span class="line">    if (liquidityDelta != 0) &#123;</span><br><span class="line">        uint32 blockTimestamp = _blockTimestamp();</span><br><span class="line"></span><br><span class="line">        // 更新 lower tikc 和 upper tick</span><br><span class="line">        // fippedX 变量表示是此 tick 的引用状态是否发生变化，即</span><br><span class="line">        // 被引用 -&gt; 未被引用 或</span><br><span class="line">        // 未被引用 -&gt; 被引用</span><br><span class="line">        // 后续需要根据这个变量的值来更新 tick 位图</span><br><span class="line">        flippedLower = ticks.update(</span><br><span class="line">            tickLower,</span><br><span class="line">            tick,</span><br><span class="line">            liquidityDelta,</span><br><span class="line">            _feeGrowthGlobal0X128,</span><br><span class="line">            _feeGrowthGlobal1X128,</span><br><span class="line">            false,</span><br><span class="line">            maxLiquidityPerTick</span><br><span class="line">        );</span><br><span class="line">        flippedUpper = ticks.update(</span><br><span class="line">            tickUpper,</span><br><span class="line">            tick,</span><br><span class="line">            liquidityDelta,</span><br><span class="line">            _feeGrowthGlobal0X128,</span><br><span class="line">            _feeGrowthGlobal1X128,</span><br><span class="line">            true,</span><br><span class="line">            maxLiquidityPerTick</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 如果一个 tick 第一次被引用，或者移除了所有引用</span><br><span class="line">        // 那么更新 tick 位图</span><br><span class="line">        if (flippedLower) &#123;</span><br><span class="line">            tickBitmap.flipTick(tickLower, tickSpacing);</span><br><span class="line">            secondsOutside.initialize(tickLower, tick, tickSpacing, blockTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">        if (flippedUpper) &#123;</span><br><span class="line">            tickBitmap.flipTick(tickUpper, tickSpacing);</span><br><span class="line">            secondsOutside.initialize(tickUpper, tick, tickSpacing, blockTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // 更新 position 中的数据</span><br><span class="line">    position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);</span><br><span class="line"></span><br><span class="line">    // 如果移除了对 tick 的引用，那么清除之前记录的元数据</span><br><span class="line">    // 这只会发生在移除流动性的操作中</span><br><span class="line">    if (liquidityDelta &lt; 0) &#123;</span><br><span class="line">        if (flippedLower) &#123;</span><br><span class="line">            ticks.clear(tickLower);</span><br><span class="line">            secondsOutside.clear(tickLower, tickSpacing);</span><br><span class="line">        &#125;</span><br><span class="line">        if (flippedUpper) &#123;</span><br><span class="line">            ticks.clear(tickUpper);</span><br><span class="line">            secondsOutside.clear(tickUpper, tickSpacing);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先忽略费率相关的操作，这个函数所做的操作是：</p>
<ul>
<li>添加&#x2F;移除流动性时，先更新这个 Positon 对应的 lower&#x2F;upper tick 中记录的元数据</li>
<li>更新 position</li>
<li>根据需要更新 tick 位图</li>
</ul>
<p>Postion 是以 <code>owner</code>, <code>lower tick</code>, <code>uppper tick</code> 作为键来存储的，注意这里的 owner 实际上是 <code>NonfungiblePositionManager</code> 合约的地址。这样当多个用户在同一个价格区间提供流动性时，在底层的 <code>UniswapV3Pool</code> 合约中会将他们合并存储。而在 <code>NonfungiblePositionManager</code> 合约中会按用户来区别每个用户拥有的 <code>Position</code>.</p>
<p>Postion 中包含的字段中，除去费率相关的字段，只有一个即流动性 L：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library Position &#123;</span><br><span class="line">    // info stored for each user&#x27;s position</span><br><span class="line">    struct Info &#123;</span><br><span class="line">        // 此 position 中包含的流动性大小，即 L 值</span><br><span class="line">        uint128 liquidity;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>更新 position 只需要一行调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);</span><br></pre></td></tr></table></figure>

<p>其中包含了 position 中流动性 L 的更新，以及手续费相关的计算。</p>
<h2 id="tick-管理"><a href="#tick-管理" class="headerlink" title="tick 管理"></a>tick 管理</h2><p>我们再来看 tick 相关的管理，在 <code>UniswapV3Pool</code> 合约中有两个状态变量记录了 tick 相关的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// tick 元数据管理的库</span><br><span class="line">    using Tick for mapping(int24 =&gt; Tick.Info);</span><br><span class="line">    // tick 位图槽位的库</span><br><span class="line">    using TickBitmap for mapping(int16 =&gt; uint256);</span><br><span class="line"></span><br><span class="line">    // 记录了一个 tick 包含的元数据，这里只会包含所有 Position 的 lower/upper ticks</span><br><span class="line">    mapping(int24 =&gt; Tick.Info) public override ticks;</span><br><span class="line">    // tick 位图，因为这个位图比较长（一共有 887272x2 个位），大部分的位不需要初始化</span><br><span class="line">    // 因此分成两级来管理，每 256 位为一个单位，一个单位称为一个 word</span><br><span class="line">    // map 中的键是 word 的索引</span><br><span class="line">    mapping(int16 =&gt; uint256) public override tickBitmap;</span><br><span class="line"></span><br><span class="line">library Tick &#123;</span><br><span class="line">    ...</span><br><span class="line">    // tick 中记录的数据</span><br><span class="line">    struct Info &#123;</span><br><span class="line">        // 记录了所有引用这个 tick 的 position 流动性的和</span><br><span class="line">        uint128 liquidityGross;</span><br><span class="line">        // 当此 tick 被越过时（从左至右），池子中整体流动性需要变化的值</span><br><span class="line">        int128 liquidityNet;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>tick 中和流动性相关的字段有两个 <code>liquidityGross</code>，<code>liquidityNet</code>。</p>
<p><code>liquidityNet</code> 表示当价格从左至右经过此 tick 时整体流动性需要变化的净值。在单个流动性中，对于 lower tick 来说，它的值为正，对于 upper tick 来说它的值为 负。</p>
<p>如果有两个 position 中的流动性相等，例如 <code>L = 500</code>，并且这两个 position 同时引用了一个 tick，其中一个为 lower tick ，另一个为 upper tick，那么对于这个 tick，它的 <code>liquidityNet = 0</code>。此时我们就需要有一种机制来判断一个 tick 是否仍然在被引用中。这里使用 <code>liquidityGross</code> 记录流动性的增值（不考虑 lower&#x2F;upper），我们可以就通过流动性变化前后 <code>liquidityGross</code> 是否等于 0 来判断这个 tick 是否仍被引用。</p>
<p>当价格变动导致 $tick_{current}$ 越过一个 position 的 lower&#x2F;upper tick 时，我们需要根据 tick 中记录的值来更新当前价格所对应的总体流动性。假设 position 的流动性值为 $\Delta L$，会有以下四种情况：</p>
<ol>
<li>token0 价格上升，即从左至右越过一个 lower tick 时， $L&#x3D;L_{current} + \Delta L$</li>
<li>token0 价格上升，即从左至右越过一个 upper tick 时， $L&#x3D;L_{current} - \Delta L$</li>
<li>token0 价格下降，即从右至左越过一个 upper tick 时， $L&#x3D;L_{current} + \Delta L$</li>
<li>token0 价格下降，即从右至左越过一个 lower tick 时， $L&#x3D;L_{current} - \Delta L$</li>
</ol>
<p><code>liquidityNet</code> 中记录的就是当从左至右穿过这个 tick 时，需要增减的流动性，当其为 lower tick 时，其值为正，当其为 upper tick 时，其值为负。对于从右至左穿过的情况，只需将 <code>liquidityNet</code> 的值去翻即可完成计算。</p>
<p>我再来看如何更新 tick 元数据，以下是 <code>tick.update</code> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function update(</span><br><span class="line">    mapping(int24 =&gt; Tick.Info) storage self,</span><br><span class="line">    int24 tick,</span><br><span class="line">    int24 tickCurrent,</span><br><span class="line">    int128 liquidityDelta,</span><br><span class="line">    uint256 feeGrowthGlobal0X128,</span><br><span class="line">    uint256 feeGrowthGlobal1X128,</span><br><span class="line">    bool upper,</span><br><span class="line">    uint128 maxLiquidity</span><br><span class="line">) internal returns (bool flipped) &#123;</span><br><span class="line">    Tick.Info storage info = self[tick];</span><br><span class="line"></span><br><span class="line">    uint128 liquidityGrossBefore = info.liquidityGross;</span><br><span class="line">    uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);</span><br><span class="line"></span><br><span class="line">    require(liquidityGrossAfter &lt;= maxLiquidity, &#x27;LO&#x27;);</span><br><span class="line"></span><br><span class="line">    // 通过 liquidityGross 在进行 position 变化前后的值</span><br><span class="line">    // 来判断 tick 是否仍被引用</span><br><span class="line">    flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    info.liquidityGross = liquidityGrossAfter;</span><br><span class="line"></span><br><span class="line">    // 更新 liquidityNet 的值，对于 upper tick，</span><br><span class="line">    info.liquidityNet = upper</span><br><span class="line">        ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()</span><br><span class="line">        : int256(info.liquidityNet).add(liquidityDelta).toInt128();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数返回的 flipped 表示此 tick 的引用状态是否发生变化，之前的 <code>_updatePosition</code> 中的代码会根据这个返回值去更新 tick 位图。</p>
<h2 id="tick-位图"><a href="#tick-位图" class="headerlink" title="tick 位图"></a>tick 位图</h2><p>tick 位图用于记录所有被引用的 lower&#x2F;upper tick index，我们可以用过 tick 位图，从当前价格找到下一个（从左至右或者从右至左）被引用的 tick index。关于 tick 位图的管理，在 <code>_updatePosition</code> 中的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (flippedLower) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickLower, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickLower, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br><span class="line">if (flippedUpper) &#123;</span><br><span class="line">    tickBitmap.flipTick(tickUpper, tickSpacing);</span><br><span class="line">    secondsOutside.initialize(tickUpper, tick, tickSpacing, blockTimestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不做进一步的说明，具体代码实现在<a target="_blank" rel="noopener" href="https://github.com/Uniswap/uniswap-v3-core/blob/2dc1eb9f251bad1c260d22dd392d8cedb2c6a4b5/contracts/libraries/TickBitmap.sol">TickBitmap库</a>中。tick 位图有以下几个特性：</p>
<ul>
<li>对于不存在的 tick，不需要初始值，因为访问 map 中不存在的 key 默认值就是 0</li>
<li>通过对位图的每个 word(uint256) 建立索引来管理位图，即访问路径为 word index -&gt; word -&gt; tick bit</li>
</ul>
<h2 id="token-数确认"><a href="#token-数确认" class="headerlink" title="token 数确认"></a>token 数确认</h2><p><code>_modifyPosition</code> 函数在调用 <code>_updatePosition</code> 更新完 Position 后，会计算出此次提供流动性具体所需的 x token 和 y token 数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function _modifyPosition(ModifyPositionParams memory params)</span><br><span class="line">    private</span><br><span class="line">    noDelegateCall</span><br><span class="line">    returns (</span><br><span class="line">        Position.Info storage position,</span><br><span class="line">        int256 amount0,</span><br><span class="line">        int256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Slot0 memory _slot0 = slot0; // SLOAD for gas optimization</span><br><span class="line"></span><br><span class="line">    position = _updatePosition(</span><br><span class="line">        ...</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里插入一个题外话，这一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Slot0 memory _slot0 = slot0; // SLOAD for gas optimization</span><br></pre></td></tr></table></figure>

<p>因为后续需要多次访问 <code>slot0</code>，这里将其读入内存中，后续的访问就可以使用 MLOAD 而不用使用 SLOAD，可以节省 gas（<strong>SLOAD 的成本比 MLOAD 高很多</strong>）。Uniswap v2 和 v3 大量使用了这个技巧。</p>
<p>这个函数在更新完 position 之后，主要做的就是通过 L 和 $\Delta \sqrt P$  计算出用户需要支付的 token 数量，我们之前已经讲过 <a target="_blank" rel="noopener" href="https://paco0x.org/uniswap-v3-1/#%e4%bb%8e-token-%e6%95%b0%e8%ae%a1%e7%ae%97%e6%b5%81%e5%8a%a8%e6%80%a7-l">从 token 数计算流动性 L</a>的三种情况，这里其实就是之前计算的逆运算，即通过 L 计算 x token 和 y token 的数量，这里不再重复赘述其公式。具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function _modifyPosition(ModifyPositionParams memory params)</span><br><span class="line">    private</span><br><span class="line">    noDelegateCall</span><br><span class="line">    returns (</span><br><span class="line">        Position.Info storage position,</span><br><span class="line">        int256 amount0,</span><br><span class="line">        int256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (params.liquidityDelta != 0) &#123;</span><br><span class="line">        // 计算三种情况下 amount0 和 amount1 的值，即 x token 和 y token 的数量</span><br><span class="line">        if (_slot0.tick &lt; params.tickLower) &#123;</span><br><span class="line">            amount0 = SqrtPriceMath.getAmount0Delta(</span><br><span class="line">                // 计算 lower/upper tick 对应的价格</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickLower),</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickUpper),</span><br><span class="line">                params.liquidityDelta</span><br><span class="line">            );</span><br><span class="line">        &#125; else if (_slot0.tick &lt; params.tickUpper) &#123;</span><br><span class="line">            // current tick is inside the passed range</span><br><span class="line">            uint128 liquidityBefore = liquidity; // SLOAD for gas optimization</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            amount0 = SqrtPriceMath.getAmount0Delta(</span><br><span class="line">                _slot0.sqrtPriceX96,</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickUpper),</span><br><span class="line">                params.liquidityDelta</span><br><span class="line">            );</span><br><span class="line">            amount1 = SqrtPriceMath.getAmount1Delta(</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickLower),</span><br><span class="line">                _slot0.sqrtPriceX96,</span><br><span class="line">                params.liquidityDelta</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amount1 = SqrtPriceMath.getAmount1Delta(</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickLower),</span><br><span class="line">                TickMath.getSqrtRatioAtTick(params.tickUpper),</span><br><span class="line">                params.liquidityDelta</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码将计算的过程封装在了 <code>SqrtPriceMath</code> 库中，<code>getAmount0Delta</code> 和 <code>getAmount1Delta</code> 分别对应公式  $L&#x3D;L_{current} + \Delta L$ 和  $\Delta y &#x3D; \Delta \sqrt P \cdot L$.</p>
<p>在具体的计算过程中，又分成了 RoundUp 和 RoundDown 两种情况，简单来说：</p>
<ol>
<li>当提供&#x2F;增加流动性时，会使用 RoundUp，这样可以保证增加数量为 L 的流动性时，用户提供足够的 token 到 pool 中</li>
<li>当移除&#x2F;减少流动性时，会使用 RoundDown，这样可以保证减少数量为 L 的流动性时，不会从 pool 中给用户多余的 token</li>
</ol>
<p>通过上述两个条件可以保证 pool 在流动性增加&#x2F;移除的操作中，不会出现坏账的情况。除了流动性操作之外，swap 操作也会使用类似机制，保证 pool 不会出现坏账。</p>
<p>同时，Uniswap v3 参考<a target="_blank" rel="noopener" href="https://2π.com/21/muldiv/index.html">这里</a>实现了一个精度较高的 $\frac {a \cdot b}c$   的算法，封装在 <code>FullMath</code> 库中。</p>
<h2 id="tick-index-sqrt-P"><a href="#tick-index-sqrt-P" class="headerlink" title="tick index -&gt; $\sqrt P$"></a>tick index -&gt; $\sqrt P$</h2><p>上面的代码还使用了 <code>TickMath</code> 库中的 <code>getSqrtRatioAtTick</code> 来通过 tick index 计算其所对应的价格，实现为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) &#123;</span><br><span class="line">    uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span><br><span class="line">    require(absTick &lt;= uint256(MAX_TICK), &#x27;T&#x27;);</span><br><span class="line"></span><br><span class="line">    // 这些魔数分别表示 1/sqrt(1.0001)^1, 1/sqrt(1.0001)^2, 1/sqrt(1.0001)^4....</span><br><span class="line">    uint256 ratio = absTick &amp; 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;</span><br><span class="line">    if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span><br><span class="line">    if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span><br><span class="line"></span><br><span class="line">    if (tick &gt; 0) ratio = type(uint256).max / ratio;</span><br><span class="line"></span><br><span class="line">    // this divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span><br><span class="line">    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint</span><br><span class="line">    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent</span><br><span class="line">    sqrtPriceX96 = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的实现通过很多的 magic number，优化了计算过程，其实现思路如下：</p>
<p>首先我们知道：</p>
<p>$<br>\sqrt P_i &#x3D; {\sqrt {1.0001}}^i<br>$</p>
<p>可以将 i i 拆解成如下形式，其中 n j n_j 表示 i i 的二进制格式中第 j j 位的值：</p>
<p>$$<br>\begin{cases}<br>i &#x3D; n_0 \cdot 1 + n_1 \cdot 2 + n_2 \cdot 4 + n_3 \cdot 8 + …. \<br>n_i \in {0, 1}<br>\end{cases}<br>$$</p>
<p>例如 i&#x3D;20&#x3D;4+16 i &#x3D; 20 &#x3D; 4 + 16<br>然后我们可以有：<br>$$<br>\begin{cases}<br>\sqrt P &#x3D; {\sqrt {1.0001}}^i &#x3D; {\sqrt {1.0001}}^{n_0 \cdot 1} \cdot {\sqrt {1.0001}}^{n_1 \cdot 2} \cdot {\sqrt {1.0001}}^{n_2 \cdot 4} \cdot {\sqrt {1.0001}}^{n_3 \cdot 8} \cdot … \<br>n_i \in {0, 1}<br>\end{cases}<br>$$<br>因为 $i \in (-887272, 887272)$，只需要 20 位二进制数可以保存其值。我们可以预先算出 ${\sqrt {1.0001}}^1,\ {\sqrt {1.0001}}^2,\ {\sqrt {1.0001}}^4,\ …,\ {\sqrt {1.0001}}^{524288}$ 的值（$524288&#x3D;2^{19}$），然后将 $i$ 值每一位的值求出，带入上面的计算公式就可以算出 $\sqrt P_i$ 的值。实际上，这段代码在上面的算法之上还进行了优化：因为 $\sqrt {P_{-i}} &#x3D; \frac 1{\sqrt P_{i}}$，所以当 $i$ 为负数时可以先将其取反，转换为正数进行计算当 $i$ 的值为正数时，计算的结果可能会很大，中间计算涉及到很多乘法运算，可能会导致计算结果溢出（它使用了 Q128.128 定点数）。所以实际计算的是 $i$ 为负数时的值，因为当 $i$ 为负数时，$\sqrt P_{i}$ 是一个小于 1 的小数，这样在进行乘法运算时则不会产生溢出。即上面代码的那些魔数分别为 $\frac 1{\sqrt {1.0001}^1},\ \frac 1{\sqrt {1.0001}^2},\ \frac 1{\sqrt {1.0001}^4},\ \frac 1{\sqrt {1.0001}^8},\ …,\ \frac 1{\sqrt {1.0001}^{524288}}$ 的值这里的计算使用了 Q128.128 精度的定点数，实际上这些魔数的值都向右移动 128 位最后，当输入是正数时，我们需要在计算的结尾计算 $\sqrt P_{i} &#x3D; \frac 1{\sqrt P_{-i}}$，即 $\sqrt P_{i}$ 的倒数，这里因为使用了 Q128.128 精度的定点数，即计算的过程是： $\frac {1«128}{\sqrt P_{-i}} « 128 &#x3D; \frac {1«256}{\sqrt P_{-i}}$，1&lt;&lt;256 可以使用 type(uint256).max 取近似值来表示最后的最后，将 Q128.128 转换为 Q64.96 并始终向上取整，以保持一致性</p>
<h2 id="sqrt-P-tick-index"><a href="#sqrt-P-tick-index" class="headerlink" title="$\sqrt P$ -&gt; tick index"></a>$\sqrt P$ -&gt; tick index</h2><p>这里顺带提一下，在交易计算中会需要进行上述计算的逆计算，给定 $\sqrt P$，需要计算出对应的 tick index，即 $log_{\sqrt {1.0001}}{\sqrt P}$ 的计算。在代码中为：TickMath.getTickAtSqrtRatio，关于这个函数的实现，可以参考我的这篇文章：Solidity 中的对数计算。</p>
<h2 id="完成流动性添加"><a href="#完成流动性添加" class="headerlink" title="完成流动性添加"></a>完成流动性添加</h2><p><code>_modifyPosition</code> 调用完成后，会返回 x token, 和 y token 的数量。再来看 <code>UniswapV3Pool.mint</code> 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function mint(</span><br><span class="line">    address recipient,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    require(amount &gt; 0);</span><br><span class="line">    (, int256 amount0Int, int256 amount1Int) =</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: recipient,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 = uint256(amount0Int);</span><br><span class="line">    amount1 = uint256(amount1Int);</span><br><span class="line"></span><br><span class="line">    uint256 balance0Before;</span><br><span class="line">    uint256 balance1Before;</span><br><span class="line">    // 获取当前池中的 x token, y token 余额</span><br><span class="line">    if (amount0 &gt; 0) balance0Before = balance0();</span><br><span class="line">    if (amount1 &gt; 0) balance1Before = balance1();</span><br><span class="line">    // 将需要的 x token 和 y token 数量传给回调函数，这里预期回调函数会将指定数量的 token 发送到合约中</span><br><span class="line">    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);</span><br><span class="line">    // 回调完成后，检查发送至合约的 token 是否复合预期，如果不满足检查则回滚交易</span><br><span class="line">    if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;= balance0(), &#x27;M0&#x27;);</span><br><span class="line">    if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;= balance1(), &#x27;M1&#x27;);</span><br><span class="line"></span><br><span class="line">    emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数关键的步骤就是通过回调函数，让调用方发送指定数量的 x token 和 y token 至合约中。</p>
<p>我们再来看 <code>NonfungiblePositionManager.mint</code> 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function mint(MintParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    IUniswapV3Pool pool;</span><br><span class="line">    // 这里是添加流动性，并完成 x token 和 y token 的发送</span><br><span class="line">    (amount0, amount1, pool) = addLiquidity(</span><br><span class="line">        AddLiquidityParams(&#123;</span><br><span class="line">            token0: params.token0,</span><br><span class="line">            token1: params.token1,</span><br><span class="line">            fee: params.fee,</span><br><span class="line">            recipient: address(this),</span><br><span class="line">            tickLower: params.tickLower,</span><br><span class="line">            tickUpper: params.tickUpper,</span><br><span class="line">            amount: params.amount,</span><br><span class="line">            amount0Max: params.amount0Max,</span><br><span class="line">            amount1Max: params.amount1Max</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 铸造 ERC721 token 给用户，用来代表用户所持有的流动性</span><br><span class="line">    _mint(params.recipient, (tokenId = _nextId++));</span><br><span class="line"></span><br><span class="line">    bytes32 positionKey = PositionKey.compute(address(this), params.tickLower, params.tickUpper);</span><br><span class="line">    (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);</span><br><span class="line"></span><br><span class="line">    // idempotent set</span><br><span class="line">    uint80 poolId =</span><br><span class="line">        cachePoolKey(</span><br><span class="line">            address(pool),</span><br><span class="line">            PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    // 用 ERC721 的 token ID 作为键，将用户提供流动性的元信息保存起来</span><br><span class="line">    _positions[tokenId] = Position(&#123;</span><br><span class="line">        nonce: 0,</span><br><span class="line">        operator: address(0),</span><br><span class="line">        poolId: poolId,</span><br><span class="line">        tickLower: params.tickLower,</span><br><span class="line">        tickUpper: params.tickUpper,</span><br><span class="line">        liquidity: params.amount,</span><br><span class="line">        feeGrowthInside0LastX128: feeGrowthInside0LastX128,</span><br><span class="line">        feeGrowthInside1LastX128: feeGrowthInside1LastX128,</span><br><span class="line">        tokensOwed0: 0,</span><br><span class="line">        tokensOwed1: 0</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个函数主要是将用户的 Position 保存起来，并给用户铸造 NFT token，代表其所持有的流动性。至此提供流动性的步骤就完成了。</p>
<h2 id="流动性的移除"><a href="#流动性的移除" class="headerlink" title="流动性的移除"></a>流动性的移除</h2><p>移除流动性就是上述操作的逆操作，在 core 合约中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function burn(</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    // 先计算出需要移除的 token 数</span><br><span class="line">    (Position.Info storage position, int256 amount0Int, int256 amount1Int) =</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: msg.sender,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: -int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 = uint256(-amount0Int);</span><br><span class="line">    amount1 = uint256(-amount1Int);</span><br><span class="line"></span><br><span class="line">    // 注意这里，移除流动性后，将移出的 token 数记录到了 position.tokensOwed 上</span><br><span class="line">    if (amount0 &gt; 0 || amount1 &gt; 0) &#123;</span><br><span class="line">        (position.tokensOwed0, position.tokensOwed1) = (</span><br><span class="line">            position.tokensOwed0 + uint128(amount0),</span><br><span class="line">            position.tokensOwed1 + uint128(amount1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除流动性时，还是使用之前的公式计算出移出的 token 数，但是并不会直接将移出的 token 数发送给用户，而是记录在了 position 的 <code>tokensOwed0</code> 和 <code>tokensOwed1</code> 上。这样做应该是为了遵循实践：<a target="_blank" rel="noopener" href="https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls">Favor pull over push for external calls</a>.</p>
<p>关于如何使用 ERC-721 token 来进行挖矿，可以参考这篇文章：<a target="_blank" rel="noopener" href="https://www.paradigm.xyz/2021/05/liquidity-mining-on-uniswap-v3/">Liquidity Mining on Uniswap v3</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://solnex.github.io">Solnex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://solnex.github.io/2024/02/16/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/">https://solnex.github.io/2024/02/16/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/uniswap-v3/">uniswap-v3</a><a class="post-meta__tags" href="/tags/amm/">amm</a><a class="post-meta__tags" href="/tags/%E9%9B%86%E4%B8%AD%E6%B5%81%E5%8A%A8%E6%80%A7/">集中流动性</a></div><div class="post-share"><div class="social-share" data-image="/img/icon.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2024/01/11/UniswapV3-1/" title="Uniswap v3 详解（一）：设计原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Uniswap v3 详解（一）：设计原理</div></div><div class="info-2"><div class="info-item-1">刚看完 Uniswap v2 的代码， Uniswap v3 就发布了。趁着这个机会就先写一个 Uniswap v3 设计与实现吧。 因为 v3 版本的实现复杂度和 v2 已经不在一个量级了，难免会有理解上的偏差，本文权当是抛砖引玉，也希望有更多的人参与讨论。因为实现比较复杂，本系列会拆分成多篇文章，持续更新。 本文假定读者都能理解 AMM 的基本概念，并且阅读过 v3 的实现细节（最好读过白皮书）来撰写的，因此不会具体解释每一个概念的实现逻辑。 前置阅读资料官方的白皮书已经比较详尽地描述了 v3 的设计原理，这里仅对白皮书中的内容做一些补充，包含本人对其中一些机制的理解和思考。 Uniswap v2 版本使用 $x \cdot y &#x3D; k$ 这样一个简洁的公式实现了 AMM Dex，正是由于其简洁易用性，使其在短短一年时间内迅速成长为 DeFi 领域的龙头项目。但是随着 DeFi 生态走过了「从无到有」的阶段，因为 v2 无法满足某些特定需求，从而诞生了 Curve、Balancer 等针对某些功能进行改进的 AMM。 简单来说，官方认为 v2 版本最大的痛点是资金利...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/01/11/UniswapV3-1/" title="Uniswap v3 详解（一）：设计原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-11</div><div class="info-item-2">Uniswap v3 详解（一）：设计原理</div></div><div class="info-2"><div class="info-item-1">刚看完 Uniswap v2 的代码， Uniswap v3 就发布了。趁着这个机会就先写一个 Uniswap v3 设计与实现吧。 因为 v3 版本的实现复杂度和 v2 已经不在一个量级了，难免会有理解上的偏差，本文权当是抛砖引玉，也希望有更多的人参与讨论。因为实现比较复杂，本系列会拆分成多篇文章，持续更新。 本文假定读者都能理解 AMM 的基本概念，并且阅读过 v3 的实现细节（最好读过白皮书）来撰写的，因此不会具体解释每一个概念的实现逻辑。 前置阅读资料官方的白皮书已经比较详尽地描述了 v3 的设计原理，这里仅对白皮书中的内容做一些补充，包含本人对其中一些机制的理解和思考。 Uniswap v2 版本使用 $x \cdot y &#x3D; k$ 这样一个简洁的公式实现了 AMM Dex，正是由于其简洁易用性，使其在短短一年时间内迅速成长为 DeFi 领域的龙头项目。但是随着 DeFi 生态走过了「从无到有」的阶段，因为 v2 无法满足某些特定需求，从而诞生了 Curve、Balancer 等针对某些功能进行改进的 AMM。 简单来说，官方认为 v2 版本最大的痛点是资金利...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Solnex</div><div class="author-info-description">Smart Contract Engineer | Building on Ethereum, Base, Arbitrum</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/solnex"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%98%93%E5%AF%B9"><span class="toc-number">1.</span> <span class="toc-text">创建交易对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CREATE2"><span class="toc-number">2.</span> <span class="toc-text">CREATE2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E6%B5%81%E5%8A%A8%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">提供流动性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-token-%E6%95%B0%E8%AE%A1%E7%AE%97%E6%B5%81%E5%8A%A8%E6%80%A7-L"><span class="toc-number">4.</span> <span class="toc-text">从 token 数计算流动性 L</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#postion-%E6%9B%B4%E6%96%B0"><span class="toc-number">6.</span> <span class="toc-text">postion 更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tick-%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">tick 管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tick-%E4%BD%8D%E5%9B%BE"><span class="toc-number">8.</span> <span class="toc-text">tick 位图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#token-%E6%95%B0%E7%A1%AE%E8%AE%A4"><span class="toc-number">9.</span> <span class="toc-text">token 数确认</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tick-index-sqrt-P"><span class="toc-number">10.</span> <span class="toc-text">tick index -&gt; $\sqrt P$</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sqrt-P-tick-index"><span class="toc-number">11.</span> <span class="toc-text">$\sqrt P$ -&gt; tick index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E6%B5%81%E5%8A%A8%E6%80%A7%E6%B7%BB%E5%8A%A0"><span class="toc-number">12.</span> <span class="toc-text">完成流动性添加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%8A%A8%E6%80%A7%E7%9A%84%E7%A7%BB%E9%99%A4"><span class="toc-number">13.</span> <span class="toc-text">流动性的移除</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/16/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/" title="Uniswap v3 详解（二）：创建交易对/提供流动性">Uniswap v3 详解（二）：创建交易对/提供流动性</a><time datetime="2024-02-15T16:00:00.000Z" title="Created 2024-02-16 00:00:00">2024-02-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/11/UniswapV3-1/" title="Uniswap v3 详解（一）：设计原理">Uniswap v3 详解（一）：设计原理</a><time datetime="2024-01-10T16:00:00.000Z" title="Created 2024-01-11 00:00:00">2024-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Solnex</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3-b1"></script><script src="/js/main.js?v=5.5.3-b1"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script>document.addEventListener('DOMContentLoaded',function(){var header=document.getElementById('page-header');if(!header)return;var headerHeight=header.offsetHeight;var ticking=false;function updateHeaderOpacity(){var scrollTop=window.pageYOffset||document.documentElement.scrollTop;var opacity=1-(scrollTop/headerHeight);opacity=Math.max(0,Math.min(1,opacity));header.style.opacity=opacity;header.style.visibility=opacity<=0?'hidden':'visible';ticking=false;}window.addEventListener('scroll',function(){if(!ticking){window.requestAnimationFrame(updateHeaderOpacity);ticking=true;}});});</script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="200" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>